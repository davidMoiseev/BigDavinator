package frc.robot;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.sensors.PigeonIMU;
<<<<<<< HEAD
=======
import com.ctre.phoenix.sensors.PigeonIMU.CalibrationMode;
import com.ctre.phoenix.sensors.PigeonIMU.PigeonState;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.SensorType;
import com.revrobotics.CANSparkMaxLowLevel.ConfigParameter;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import org.hotteam67.HotController;
import org.hotteam67.HotLogger;
import org.hotteam67.HotPathFollower;
import org.hotteam67.HotPathFollower.State;

>>>>>>> origin/master
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.constants.WiringIDs;
import edu.wpi.first.wpilibj.Timer;

<<<<<<< HEAD


public class DriveTrain {
	
    public static final int TALON_LF = 7;
    public static final int TALON_RF = 2;
    public static final int TALON_RB = 3;
    public static final int TALON_LB = 6;
    public static final int TALON_LM = 5;
    public static final int TALON_RM = 4;
    public static final int TALON_H = 1;
    public static final int TALON_PIGEON = 6;
    
    // WPI_TalonSRX pigeon = new WPI_TalonSRX(TALON_PIGEON);
    WPI_TalonSRX LFTalon = new WPI_TalonSRX(TALON_LF);
    WPI_TalonSRX RFTalon = new WPI_TalonSRX(TALON_RF);
    WPI_TalonSRX RBTalon = new WPI_TalonSRX(TALON_RB);
    WPI_TalonSRX LBTalon = new WPI_TalonSRX(TALON_LB);
    WPI_TalonSRX HTalon = new WPI_TalonSRX(TALON_H);
    WPI_TalonSRX LMTalon = new WPI_TalonSRX(TALON_LM);
    WPI_TalonSRX RMTalon = new WPI_TalonSRX(TALON_RM);
  
    public PigeonIMU pigeon = new PigeonIMU(LBTalon);
    VisionMotion vmotion = new VisionMotion();

    HotSticks hotDrive = new HotSticks(0);
    Solenoid solenoid = new Solenoid(0);
    public double turn = hotDrive.getStickRX();
    public double  forward = hotDrive.getStickRY();  
	private double leftEncoder;
	private double rightEncoder;
	private double[] xyz_dps = new double [3];
    private double currentYaw = 0;
    public double h;
    public double speedH;
    public boolean isHDown;
    public double previousCanSeeTarget;
    public double prevprevCanSeeTarget;
    public static final double pGain = 0.04;
    public static final double iGain = 0.000008;
    public static final double dGain = 0.0;
    public double integral = 0;
    public double speed = 0;
    public double Lspeed;
    public double Rspeed;
    public double pAngle;
    public double iAngle;
    public int state;
    
    public void DrivetrainConfig(){

        LFTalon.configFactoryDefault();
        RFTalon.configFactoryDefault();
        LMTalon.configFactoryDefault();
        RMTalon.configFactoryDefault();
        LBTalon.configFactoryDefault();
        RBTalon.configFactoryDefault();
 
        LFTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, 100);
        RFTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, 100);
 
        LFTalon.setSelectedSensorPosition(0);
        RFTalon.setSelectedSensorPosition(0);
        HTalon.setSelectedSensorPosition(0);
 
        LFTalon.selectProfileSlot(0, 0);
        RFTalon.selectProfileSlot(0, 0);
        LFTalon.configNominalOutputForward(0, 100);
        RFTalon.configNominalOutputForward(0, 100);
        LFTalon.configNominalOutputReverse(0, 100);
        RFTalon.configNominalOutputReverse(0, 100);
        LFTalon.configPeakOutputForward(1, 100);
        RFTalon.configPeakOutputForward(1, 100);
        LFTalon.configPeakOutputReverse(-1, 100);
        RFTalon.configPeakOutputReverse(-1, 100);
 
        LFTalon.setSensorPhase(true);
 
        LFTalon.set(ControlMode.PercentOutput, 0.0);
        RFTalon.set(ControlMode.PercentOutput, 0.0);
        HTalon.set(ControlMode.PercentOutput, 0.0);
 
        pigeon.setYaw(0);
        RMTalon.set(ControlMode.Follower, RFTalon.getDeviceID());
        RBTalon.set(ControlMode.Follower, RFTalon.getDeviceID());
        LMTalon.set(ControlMode.Follower, LFTalon.getDeviceID());
        LBTalon.set(ControlMode.Follower, LFTalon.getDeviceID());
 
    }

    public void dropH(boolean state){
        solenoid.set(state);
        if(state == true) {
            isHDown = true;
        }
        else{
            isHDown = false;
        }
    }

    public void automaticDropH(){
        if(HTalon.getMotorOutputPercent() > 0.05){
            this.dropH(true);
        }else if(HTalon.getMotorOutputPercent() < -0.05){
            this.dropH(true);
        }else{
            this.dropH(false);
        }
    }

    public void zeroSensors(){
        LFTalon.setSelectedSensorPosition(0,0,0);
        RFTalon.setSelectedSensorPosition(0,0,0);
        pigeon.setYaw(0,0);
    }

    public void getYaw(){
        pigeon.getYawPitchRoll(xyz_dps);
        currentYaw = -1.0 * Math.toRadians(xyz_dps[0]); 
    }
 
    public void driveManualH(double kFwd, double kTurn, double kSpeed, double kH){
        hotDrive.setDeadBandRY(0.1);
        hotDrive.setDeadBandLX(0.1);
        hotDrive.setDeadBandRX(0.1);
        turn =  hotDrive.getStickRX();
        h = -hotDrive.getStickLX();
        forward = -hotDrive.getStickLY();
        double speedR = (forward * kFwd) + (turn * kTurn);
        double speedL = -(forward * kFwd) + (turn * kTurn);
        speedH = (h * kH);
        if(speedR > 1){
            speedR = 1;
        }else if(speedL > 1){
            speedL = 1;
        }
        if(hotDrive.getButtonA() == true){
            this.dropH(true);
        }else if(Math.abs(speedH) > 0.1){
            this.dropH(true);
        }else{
            this.dropH(false);
        }
        if((speedR <= 1) && (speedL <= 1) && (speedH <= 1)){
            RFTalon.set(ControlMode.PercentOutput, (speedR * kSpeed));
            LFTalon.set(ControlMode.PercentOutput, (speedL * kSpeed));
            HTalon.set(ControlMode.PercentOutput, (speedH));
        }
    }

	
	public void readSensors() {
        leftEncoder = LFTalon.getSelectedSensorPosition(0);
        rightEncoder = RFTalon.getSelectedSensorPosition(0);     
	}
	
	public void allOff() {
        LFTalon.set(ControlMode.PercentOutput, 0.0);
        RFTalon.set(ControlMode.PercentOutput, 0.0);
	}
	
	public boolean turnComplete(double heading) {
        LFTalon.set(ControlMode.PercentOutput, 0.2);
        RFTalon.set(ControlMode.PercentOutput, 0.2);
		if (currentYaw > Math.toDegrees(heading)) {
			return true;
		} else {
			return false;
		}
    }
    
    public boolean lineUp(double pipeline){
        vmotion.setPipeline(pipeline);
        HTalon.set(ControlMode.PercentOutput, vmotion.shuffleVisionPID());
        LFTalon.set(ControlMode.PercentOutput, vmotion.outputL());
        RFTalon.set(ControlMode.PercentOutput, -vmotion.outputR());
        if(vmotion.reachedTarget() == true){
            return true;
        }else{
            return false;
        }
    }

    public boolean gyroLineUp(double pipeline, double maxOutput, double target){
            switch (state){
                case 0:
                    vmotion.setPipeline(pipeline);
                    this.getYaw();
                    vmotion.getTargetAngle(currentYaw);
                    vmotion.setGyroLineUpVars();
                    state++;
                    break;
                case 1:
                    vmotion.gyroTargetLineUp(currentYaw, maxOutput);
                    HTalon.set(ControlMode.PercentOutput, vmotion.outputGyroH(currentYaw, maxOutput));
                    LFTalon.set(ControlMode.PercentOutput, vmotion.outputGyroL(currentYaw, maxOutput));
                    RFTalon.set(ControlMode.PercentOutput, -vmotion.outputGyroR(currentYaw, maxOutput));
                    break;
            }
            if(vmotion.targetReached(target) == true){
                return true;
            }else{
                return false;
            }
    }

	public void writeDashBoard() {
        SmartDashboard.putNumber("leftEncoder", leftEncoder);
        SmartDashboard.putNumber("rightEncoder", rightEncoder);
        SmartDashboard.putNumber("currentYaw", currentYaw);
        SmartDashboard.putBoolean("Is h down", isHDown);
        vmotion.writeDashBoardVis();
        SmartDashboard.putNumber("outputL", vmotion.outputGyroL(xyz_dps[0], 0.3));
        SmartDashboard.putNumber("outputR", vmotion.outputGyroR(xyz_dps[0], 0.3));
        SmartDashboard.putNumber("outputLtalon", LFTalon.getMotorOutputPercent());
        SmartDashboard.putNumber("outputRtalon", RFTalon.getMotorOutputPercent());
        SmartDashboard.putNumber("outputH", vmotion.outputGyroH(xyz_dps[0], 0.3));
        SmartDashboard.putNumber("outputHtalon", HTalon.getMotorOutputPercent());
    } 
    
    public void arcadeDrive(double f, double t)
    {
        LFTalon.set(ControlMode.PercentOutput, f + t);
        RFTalon.set(ControlMode.PercentOutput, f - t);
        
=======
public class DriveTrain implements IPigeonWrapper
{
    public static final double WHEEL_DIAMETER = 4.0 * 2.54 / 100;
    public static final int TICKS_PER_REVOLUTION = 1;

    public static final double ENCODER_TO_REVS = (50.0 / 12.0) * (42.0 / 24.0);

    public static final double SECOND_ENCODER_TO_REVS = 4096 * (42.0 / 24.0);

    // Recorded max velocity: 3000 units per 100 ms
    // 21,080.986
    public static final double TICKS_PER_METER = 22000;

    public static final double MAX_VELOCITY_TICKS = 8000;
    // Max velocity in m/s
    public static final double MAX_VELOCITY = (MAX_VELOCITY_TICKS / TICKS_PER_METER) * 10;

    /**
     * Primary motor controllers
     */
    private final CANSparkMax rightMotor;
    private final CANSparkMax leftMotor;

    /**
     * Following motor controllers
     */
    private final CANSparkMax rightFollower;
    private final CANSparkMax leftFollower;

    private final CANSparkMax hDriveMotor;

    private final PigeonIMU pigeon;

    private final TalonSRX rightEncoder;
    private final TalonSRX leftEncoder;
    private double[] xyz_dps = new double[3];
    private double HDriveOutputOld;
    private int Hstate;
    double k;
    double spike;
    double kAlt;

    // values without offset
    private double leftEncoderValue = 0;
    private double rightEncoderValue = 0;

    private final HotPathFollower pathFollower;

    /**
     * Motion Profiling Constants
     */
    public static final class POS_PIDVA
    {
        public static final double P = .75;
        public static final double I = 0;
        public static final double D = 0;
        public static final double V = 1.0 / MAX_VELOCITY; // Velocity feed forward
        public static final double A = 0; // Acceleration gain
    }

    /**
     * Only using P rn for ANGLE_PID
     */
    public static final class ANGLE_PID
    {
        public static final double P = .8 * (-1.0 / 80.0);
    }

    /**
     * Drivetrain class will load paths from disk and so takes a little bit of time
     */
    public DriveTrain()
    {
        rightMotor = new CANSparkMax(WiringIDs.RIGHT_DRIVE_1, MotorType.kBrushless);
        rightFollower = new CANSparkMax(WiringIDs.RIGHT_DRIVE_2, MotorType.kBrushless);

        leftMotor = new CANSparkMax(WiringIDs.LEFT_DRIVE_1, MotorType.kBrushless);
        leftFollower = new CANSparkMax(WiringIDs.LEFT_DRIVE_2, MotorType.kBrushless);

        hDriveMotor = new CANSparkMax(WiringIDs.H_DRIVE, MotorType.kBrushless);

        rightEncoder = new TalonSRX(WiringIDs.RIGHT_ELEVATOR);
        leftEncoder = new TalonSRX(WiringIDs.INTAKE);

        rightEncoder.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
        leftEncoder.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);

        leftEncoder.setSensorPhase(true);
        ;

        pigeon = new PigeonIMU(WiringIDs.PIGEON_BASE);

        leftMotor.setInverted(true);
        leftFollower.setInverted(true);

        leftFollower.follow(leftMotor);
        rightFollower.follow(rightMotor);

        /**
         * Path controller, can be configured to use different paths after construction.
         * This call loads from disk
         */
        pathFollower = new HotPathFollower(SECOND_ENCODER_TO_REVS, WHEEL_DIAMETER, Paths.TestPath2.Left,
                Paths.TestPath2.Right);
        pathFollower.ConfigAngleP(ANGLE_PID.P);
        pathFollower.ConfigPosPIDVA(POS_PIDVA.P, POS_PIDVA.I, POS_PIDVA.D, POS_PIDVA.V, POS_PIDVA.A);
    }

    /**
     * Control the path follower, should be called on the same period as the
     * profile's time step
     * 
     * @return whether the path is complete
     */
    public boolean FollowPath()
    {
        double heading = xyz_dps[0];
        HotPathFollower.Output pathOutput = pathFollower.FollowNextPoint(leftEncoderValue, rightEncoderValue, -heading);

        rightMotor.set(pathOutput.Left);
        leftMotor.set(pathOutput.Right);

        return (pathFollower.GetState() == State.Complete);
    }

    /**
     * Read the sensors into memory
     */
    public void readSensors()
    {
        rightEncoderValue = rightEncoder.getSelectedSensorPosition();
        leftEncoderValue = leftEncoder.getSelectedSensorPosition();
        pigeon.getYawPitchRoll(xyz_dps);
    }

    /**
     * Write to logs and dashboards
     */
    public void writeLogs()
    {
        SmartDashboard.putNumber("rightEncoder", rightEncoderValue);
        SmartDashboard.putNumber("leftEncoder", leftEncoderValue);
        SmartDashboard.putNumber("currentYaw", xyz_dps[0]);
        SmartDashboard.putNumber("currentVelocityRight", rightEncoder.getSelectedSensorVelocity());
        SmartDashboard.putNumber("currentVelocityLeft", leftEncoder.getSelectedSensorVelocity());

        /*
         * SmartDashboard.putNumber("motorType", leftMotor.getMotorType().value);
         * SmartDashboard.putNumber("motorEncoderConfiguration",
         * leftMotor.getParameterInt(ConfigParameter.kSensorType).get());
         */
        HotLogger.Log("rightEncoder", rightEncoderValue);
        HotLogger.Log("leftEncoder", leftEncoderValue);
        HotLogger.Log("currentYaw", xyz_dps[0]);
        HotLogger.Log("currentVelocityRight", rightEncoder.getSelectedSensorPosition());
        HotLogger.Log("currentVelocityLeft", leftEncoder.getSelectedSensorVelocity());
    }

    /**
     * Clear all measured sensor values in memory and zero the pigeon
     */
    public void zeroSensors()
    {
        pigeon.setYaw(0);
        leftEncoder.setSelectedSensorPosition(0);
        rightEncoder.setSelectedSensorPosition(0);
        leftEncoderValue = 0;
        rightEncoderValue = 0;
        xyz_dps = new double[]
        { 0, 0, 0 };
        pathFollower.Reset();
    }

    /**
     * Motor output to zero
     */
    public void zeroMotors()
    {
        rightMotor.set(0);
        leftMotor.set(0);
        hDriveMotor.set(0);
    }

    /**
     * Manual control, includes deadband
     * 
     * @param turn
     *                    turn offset for motor output
     * @param forward
     *                    primary forward/backwards output
     * @param side
     *                    the hdrive output value
     */
  
    public void Update(HotController joystick)
    {
        //(joystick.getStickRX(), -driver.getStickLY(), (driver.getRawAxis(3) - driver.getRawAxis(2)) / 2.0);
        
        rightMotor.set(-joystick.getStickLY() - joystick.getStickRX());
        leftMotor.set(-joystick.getStickLY() + joystick.getStickRX() + 0.15*(HDriveOutput(joystick)));
        hDriveMotor.set(HDriveOutput(joystick));
    }
    public double HDriveOutput(HotController joystick)
    {
     double HDriveOutput = ((joystick.getRawAxis(3) - joystick.getRawAxis(2)) / 2.0);
     HDriveOutputOld = HDriveOutput;
     Hstate = 0;
     k = 0.02;
     spike = 0.3;
     kAlt = 0.5;
     //start up if statements spike in the positive and negative/ or do nothing
        //Negative
        if ((Hstate == 0) && (HDriveOutput - HDriveOutputOld) < 0.0 && HDriveOutputOld == 0.0)
        {   
            HDriveOutput = HDriveOutput - spike;
            Hstate++;
        }
        //Nothing
        if ((Hstate == 0) && (HDriveOutput - HDriveOutputOld) == 0.0 && Math.abs(HDriveOutputOld) == 0.0) 
        {
            HDriveOutputOld = HDriveOutput;
            Hstate = 0;
        }
        //Positive
        if (((Hstate == 0) && (HDriveOutput - HDriveOutputOld) > 0.0 && Math.abs(HDriveOutputOld) == 0.0))
        {
               HDriveOutput = HDriveOutput + spike;
               Hstate++;
        }
        //once moving, either no change, keep state, positive ramp up  or ramp down accordingly

        //if at extremes of 0.5 + where spike should be lesser than 0.3
        if ((Hstate == 1) && Math.abs(HDriveOutput- HDriveOutputOld)> 1.0 && HDriveOutputOld > 0.5)
        {
            if(HDriveOutput > 0.0)
            {
                HDriveOutput = Math.abs(HDriveOutput) + kAlt;
                Hstate = 1;
            }
            else 
            {
                HDriveOutput = HDriveOutput - kAlt;
                Hstate = 1;
            }
        }
        //nothing
        if ((Hstate == 1) && (HDriveOutput - HDriveOutputOld) == 0.0 && Math.abs(HDriveOutputOld) > 0.0)
        {
            HDriveOutput = HDriveOutputOld;
            Hstate = 1;
        }
        //ramp up
        if ((Hstate == 1) && Math.abs(HDriveOutput - HDriveOutputOld) > 0.0 && Math.abs(HDriveOutputOld) > 0.0)
        {
           if(HDriveOutput > 0.0)
           {
                HDriveOutput = Math.abs(HDriveOutput) + k;
                Hstate = 1;
           }
           else
           {
                HDriveOutput = HDriveOutput - k;
                Hstate = 1;
           }
        }
        //ramp down
        if ((Hstate == 1) && (HDriveOutput - HDriveOutputOld) < 0.0 && Math.abs(HDriveOutputOld) > 0.0)
        {
            if(HDriveOutput > 0.0)
            {
                HDriveOutput = Math.abs(HDriveOutput) + k;
                Hstate = 0;
            }
            else 
            {
                HDriveOutput = HDriveOutput - k;
                Hstate = 0;
            }
        }
        //once moving, either no change, keep state, negative ramp up or ramp down accordingly
        return HDriveOutput;
    }
    /**
     * Configure the Talon to Calibrate once the robot is stable
     */
    @Override
    public void CalibratePigeon()
    {
        pigeon.enterCalibrationMode(CalibrationMode.BootTareGyroAccel);
    }

    /**
     * Whether the current state of the Pigeon is Ready
     */
    @Override
    public boolean PigeonReady()
    {
        return (pigeon.getState() == PigeonState.Ready);
>>>>>>> origin/master
    }
}